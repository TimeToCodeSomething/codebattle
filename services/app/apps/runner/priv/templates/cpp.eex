#include "../precompiled.hpp"

// Forward declare the solution function instead of including solution.cpp
// This allows us to compile solution.cpp separately and link it later
int solution(<%= arguments_expression %>);

using namespace std;

int main() {
  std::stringstream buffer_;
  std::streambuf * oldBuf_ = std::cout.rdbuf(buffer_.rdbuf());
  bool success_ = true;
  string output_ = "";
  vector<json> finalResults_ = {};

  try {
    <%= for %{arguments: arguments, index: i} <- checks do %>
      <%= for %{defining: defining, value: value} <- arguments.info do %>
        <%= defining %> = <%= value %>;
      <% end %>

      int expected<%= i %> = <%= expected %>;

      auto start<%= i %>_ = std::chrono::high_resolution_clock::now();
      auto result<%= i %>_ = solution(<%= arguments.expression %>);
      auto executionTime<%= i %>_ = std::chrono::duration<double>(std::chrono::high_resolution_clock::now() - start<%= i %>_).count();
      output_ = buffer_.str();
      buffer_.str("");
      success_ = AssertSolution(result<%= i %>_, expected<%= i %>, output_, "<%= arguments.expression %>", executionTime<%= i %>_, finalResults_, success_);
    <% end %>

    if (success_) {
      json message = BuildMessage("ok", "__seed:<%= seed %>__");
      finalResults_.push_back(message);
    }
  } catch (const std::exception& e) {
    json message = BuildMessage("error", e.what());
    finalResults_.push_back(message);
  }

  std::cout.rdbuf(oldBuf_);
  for_each(finalResults_.begin(), finalResults_.end(), SendMessage);
  cout << buffer_.str() << "\n";
}
